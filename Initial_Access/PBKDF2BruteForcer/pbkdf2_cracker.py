#!/usr/bin/env python3
#-*- coding: UTF-8 -*-

'''
Brute Force and/or Check passwords against Redhat's 389-ds PBDKD2_SHA256 hashes

        NAME:
                pbkdf2_cracker.py
        VERSION:
                1.0.0
        AUTHOR:
                Jesse Leverett (CyberThulhu)
        STATUS:
                Functional:
                Missing output method/functionality
        TO-DO:
                Clean Code:
                Add Error Handling:
                Add Output Function:
                Update more Verbosity:

COPYRIGHT Â© 2022 Jesse Leverett
'''

# Using Rules for Password List:
# hashcat --force list.txt -r /usr/share/hashcat/rules/best64.rule --stdout > new_password.lst

# Getting LDAP Dump:
# ldapsearch -D "cn=Directory Manager" -x -W -b 'cn=users,cn=accounts,dc=ntdomain,dc=local' \
# uid userpassword krbprincipalkey sambalmpassword sambantpassword

# You may be able to obtain DJANGO hashes as well, such as from a Database, etc.

# Imports
from __future__ import absolute_import
from __future__ import print_function
import os
import sys
import time
import shlex
import base64
import socket
import struct
import hashlib
import argparse
import traceback
import subprocess
from queue import Queue
from typing import Tuple
from threading import Thread
try:
    from passlib.hash import django_pbkdf2_sha256 as django_pbkdf2_hash
    PASSLIB_HASH_DJANGO_PBKDF2_SHA256 = True
    print("[!] Passlib Library detected... Enabling New Switches. Run help new options.")
except ImportError:
    PASSLIB_HASH_DJANGO_PBKDF2_SHA256 = False

# Added Variables
__author__ = "Jesse Leverett"
__copyright__ = "Copyright (C) 2022 Jesse Leverett"
__license__ = "MIT License"
__version__ = "1.0"
PASSWORD_GUESS_QUEUE = None

# Argparser
PROG = "pbkdf2_cracker"
PROG_DESCRIPTION = "Brute Force and/or Check passwords against Redhat's 389-ds PBDKD2_SHA256 hashes"
PROG_EPILOG = " Copyright (C) 2022 || Credit to 'thesubtlety' "
if PASSLIB_HASH_DJANGO_PBKDF2_SHA256 is False:
    PROG_USAGE = 'pbkdf2_cracker [-h] [--version] [-t 1] [-v] [-o OUT] '
    PROG_USAGE += '(-p PASS | -pl pass.lst) (--hash HASH | -hl hash.lst | -g)'
elif PASSLIB_HASH_DJANGO_PBKDF2_SHA256 is True:
    PROG_USAGE = 'pbkdf2_cracker [-h] [--version] [-t 1] [-v] [-o OUT] '
    PROG_USAGE += '(-p PASS | -pl pass.lst) (--hash HASH | -hl hash.lst | -g) '
    PROG_USAGE += '[-d [-r 29000] [-ss 12] [-s SALTSTR]]'
OUTPUTF_HELP_TEXT = "Path to Output File"
VERBOSE_HELP_TEXT = "Switch to Enable Verbosity"
VERSION_HELP_TEXT = "Print Version Information"
PWDHASH_HELP_TEXT = r"Password Hash ({PBKDF2_SHA256}AAnE...)"
PASSWRD_HELP_TEXT = "Clear Text Password"
GENHASH_HELP_TEXT = "Generates a Hash using Supplied Password"
PASSLST_HELP_TEXT = "Path to List of Passwords (rockyou.txt)"
HASHLST_HELP_TEXT = "Path to List of PBKDF2 Hashes (Format Each on a New Line with username:hash)"
THREADN_HELP_TEXT = "Provide number of Threads (Default: 1)"

# Instantiate Argparser
parser = argparse.ArgumentParser( prog=PROG, description=PROG_DESCRIPTION,
                                usage=PROG_USAGE, epilog=PROG_EPILOG,
                                formatter_class= argparse.RawDescriptionHelpFormatter)
password_parser = parser.add_mutually_exclusive_group(required=True)
hashword_parser = parser.add_mutually_exclusive_group(required=True)
# Standard Parsed Arguments
parser.add_argument('-o', '--output', metavar=r'./output.txt',
                    type=str, required=False, help=OUTPUTF_HELP_TEXT)
parser.add_argument('-v', '--verbose', required=False,
                    action='store_true', help=VERBOSE_HELP_TEXT)
parser.add_argument('-t', '--threads', metavar="1", default=1,
                    type=int, required=False, help=THREADN_HELP_TEXT)
parser.add_argument('--version', action="version",
                    version=f" %(prog)s {__version__}", help=VERSION_HELP_TEXT)

if PASSLIB_HASH_DJANGO_PBKDF2_SHA256:
    # DJANGO PBKDF2_SHA256 HASH ADD-ON
    DJANGOS_HELP_TEXT = "Switch to enable Django PBKDF2 SHA256 Hash Formating"
    DJANGO_ROUND_TEXT = "Optional number of rounds to use. (Default: 29000)"
    DJANGO_SALTS_TEXT = "Optional number of chars when autogenerating salts. (Default: 12)"
    DJANGOS_SALT_TEXT = "Optional salt str. A 12 char salt will be created (Optional: [0-9a-zA-Z])"
    django_parser = parser.add_argument_group()
    django_parser.add_argument('-d', '--django', dest="django",
                            required=False, action='store_true', help=DJANGOS_HELP_TEXT)
    django_parser.add_argument('-r', '--rounds', dest="rounds",
                            required=False, default=29000, type=int, help=DJANGO_ROUND_TEXT)
    django_parser.add_argument('-ss, --saltsize', dest="saltsize",
                            required=False, default=12, type=int, help=DJANGO_SALTS_TEXT)
    django_parser.add_argument('-s', '--salt', dest="salt",
                            required=False, type=str, help=DJANGOS_SALT_TEXT)

# Password Arguments
password_parser.add_argument('-p', '--password', type=str,
                            metavar='password', required=False, help=PASSWRD_HELP_TEXT)
password_parser.add_argument('-pl', '--passlist',
                            metavar='passwords.lst', required=False, help=PASSLST_HELP_TEXT)

# Hash Arguments
hashword_parser.add_argument('--hash', dest='password_hash', type=str,
                            metavar='{PBKDF2_SHA256}AAnE...', required=False,
                            help=PWDHASH_HELP_TEXT)
hashword_parser.add_argument('-hl', '--hashlist', metavar='hashes.lst',
                            required=False, help=HASHLST_HELP_TEXT)
hashword_parser.add_argument('-g', '--generate', required=False,
                            action='store_true', help=GENHASH_HELP_TEXT)

# Parse Arguments
args = parser.parse_args()

# Defined Functions
def open_file(filename:str) -> list:
    '''
    Opens a Password List/Hash List File (if Provided).

            Parameters:
            ----------
                    filename (str): File/Path to File that is opened.

            Returns:
            -------
                    file_lines (list): Python List of Hashes/Passwords.
    '''
    file_encoding, response = "UTF-8", "hashes"
    if args.passlist is filename:
        file_encoding, response = "ISO-8859-1", "passwords"
    with open(filename, encoding=file_encoding) as opened_file:
        file_lines = [e.strip() for e in opened_file.readlines() if e.strip()]
    print(f"Loaded {len(file_lines)} {response}...")
    return file_lines

def check_password_hash(username:str, userhash:str, passlist:list) -> None:
    '''
    Checks Passwords and Hashes and prints matches.

            Parameters:
            ----------
                    username (str): Name of User.
                    userhash (str): PBKDF2_SHA256 Hash of User's Password
                    passlist (list): List of testcase passwords

            Returns:
            -------
                    None
    '''
    for ct_password in passlist:
        command = f"python3 {shlex.quote(sys.argv[0])} "
        command += f"-p {shlex.quote(ct_password)} "
        command += f"--hash {shlex.quote(userhash)}"
        if args.django is not None and args.django is True:
            command += f" --django -ss {args.saltsize} -r {args.rounds}"
            if args.salt is not None:
                command += f" -s {shlex.quote(args.salt)}"
        arguments = shlex.split(command)
        with subprocess.Popen(arguments, stdout=subprocess.PIPE) as sub_process:
            passlist = sub_process.communicate()
            if b"Success!:" in passlist:
                print(f"SUCCESS => {username}: {ct_password}")
                return

def ct_password_worker(passlist:list) -> None:
    '''
    Worker Function to pass Passwords and/or Hashes to compare method.
    
            Parameters:
            ----------
                    passlist (list): List of testcase passwords.

            Returns:
            -------
                    None
    '''
    while True:
        username, userhash = PASSWORD_GUESS_QUEUE.get()
        try:
            check_password_hash(username, userhash, passlist)
        except Exception:
            traceback.print_exc(file=sys.stdout)
        PASSWORD_GUESS_QUEUE.task_done()

def base64_hash_from_data(tmp_key:str, salt:str, iterations:int) -> str:
    '''
    Base64 Hash from provided Data

            Parameters:
            ----------
                    tmp_key (str):
                    salt (str):
                    iterations (int):

            Returns:
            -------
                    buffer (str): PBKDF2_SHA256 Hash
    '''
    iteration = int(iterations)
    iteration_bytes = struct.pack("I", socket.htonl(iteration))
    raw = iteration_bytes + salt + tmp_key
    buffer = "{PBKDF2_SHA256}" + str(base64.b64encode(raw))
    if args.verbose:
        print_iter = "Iterations:\n\\x"
        print_iter += "\\x".join(hex(c)[2:] for c in bytearray(iteration_bytes))
        print_iter += f"({iterations})"
        print(print_iter)
        print("\nSalt:\n\\x" + "\\x".join(hex(c)[2:] for c in bytearray(salt)))
        print("\nKey:\n\\x" + "\\x".join(hex(c)[2:] for c in bytearray(tmp_key)))
        print()
    return buffer

def extract_hash_info(password_hash_389:str) -> Tuple[int,bytes,bytes]:
    '''
    Extracts 389-DS Hash Information

            Parameters:
            ----------
                    password_hash_389 (str): PBKDF2_SHA256 Hash String

            Returns:
            -------
                    iterations (int): Number of Iterations for the Hash
                    salt (bytes): Salt used for the Hash
                    target_key (bytes): Key used for the Hash
    '''
    if password_hash_389[0] == "{":
        password_hash_389 = password_hash_389[15:]
    hash_bytes = base64.b64decode(password_hash_389)
    iteration_bytes = hash_bytes[0:4]
    iterations = int(socket.htonl(struct.unpack("I",iteration_bytes)[0]))
    assert iterations < 1000000
    salt = hash_bytes[4:68]
    target_key = hash_bytes[68:]
    return iterations, salt, target_key

def generate_pbkdf2_hash(ct_password:str=args.password) -> str:
    '''
    Generate PBKDF2 Hash with a Provided Plaintext Password

            Parameters:
            ----------
                    ct_password (str) -> args.password: Clear Text Password to be converted to hash

            Returns:
            -------
                    pbkdf2_generated_hash (str): PBKDf2_SHA256 Generated Hash
    '''
    if PASSLIB_HASH_DJANGO_PBKDF2_SHA256:
        if args.django is not None and args.django is True:
            dround = args.rounds
            dsalts = args.saltsize
            dsalt = args.salt
            if dsalt is None:
                pbkdf2_generated_hash = django_pbkdf2_hash.hash(ct_password, rounds=dround, salt_size=dsalts)
                return pbkdf2_generated_hash
            pbkdf2_generated_hash = django_pbkdf2_hash.hash(ct_password, rounds=dround, salt_size=dsalts, salt=dsalt)
            return pbkdf2_generated_hash
    password = bytes(str(ct_password).encode('UTF-8'))
    salt = bytes(os.urandom(64))
    iterations = 10000
    temporary_key = hashlib.pbkdf2_hmac('sha256', password, salt, iterations, 256)
    pbkdf2_generated_hash = base64_hash_from_data(temporary_key, salt, iterations)
    return pbkdf2_generated_hash

def start_threads(password_list:list, threads:int=args.threads) -> None:
    '''
    Starts Threads based on Threading Argument
    Passes password list to worker method per Thread
    (Default: 1)

            Parameters:
            ----------
                    password_list (list): List of Passwordst
                    threads (int) -> args.threads: Number of threads for to spawn.

            Returns:
            -------
                    None
    '''
    for _ in range(0,threads):
        thread_object = Thread(target=ct_password_worker, args=[password_list], daemon=True)
        thread_object.start()

def run_compare(ct_password:str=args.password, hash_password:str=args.password_hash) -> None:
    '''
    Compares Generated PBKDF2 Hash from Cleartext Password to provided Hash to find match.

            Parameters:
            ----------
                    ct_password (str) -> args.password: Cleartext Password that will be converted to PBKDF2_SHA256
                    hash_password (str) -> args.password_hash: PBKDF2_SHA256 Hash to Compare against

            Returns:
            -------
                    None *(prints a string)
    '''
    password = bytes(str(ct_password).encode('UTF-8'))
    iterations, salt, target_key = extract_hash_info(hash_password)
    temporary_key = hashlib.pbkdf2_hmac('sha256', password, bytes(salt), iterations, 256)

    if args.verbose:
        print(base64_hash_from_data(temporary_key, salt, iterations))

    if target_key == temporary_key:
        print("Success!:")
        print(f"{hash_password} : {ct_password}")
    else:
        print("\nIncorrect Password\n")

def dj_run_compare(ct_password:str=args.password, hash_password:str=args.password_hash) -> None:
    '''
    Compares Generated PBKDF2 Hash from Cleartext Password to provided DJANGO Hash to find match.

            Parameters:
            ----------
                    ct_password (str) -> args.password: Cleartext Password that will be converted to PBKDF2_SHA256
                    hash_password (str) -> args.password_hash: PBKDF2_SHA256 Hash to Compare against

            Returns:
            -------
                    None *(prints a string)
    '''
    dj_compare = django_pbkdf2_hash.verify(secret=ct_password, hash=hash_password)
    if dj_compare is True:
        print("Success!:")
        print(f"{hash_password} : {ct_password}")
    else:
        print("\nIncorrect Password\n")

def main() -> None:
    '''
    Main Method

            Parameters:
            ----------
                    None

            Returns:
            -------
                    None
    '''
    # Generate a PBKDF2 Key
    try:
        global PASSWORD_GUESS_QUEUE
        if args.generate:
            print(generate_pbkdf2_hash())

        # One Password & One Hash
        if args.password and args.password_hash:
            if PASSLIB_HASH_DJANGO_PBKDF2_SHA256 is False:
                run_compare()
            elif PASSLIB_HASH_DJANGO_PBKDF2_SHA256 is True:
                dj_run_compare()

        # Both has Files
        if args.passlist and args.hashlist:
            PASSWORD_GUESS_QUEUE = Queue()
            hashes_list = open_file(args.hashlist)
            passwd_list = open_file(args.passlist)
            start_threads(passwd_list)
            for hash_line in hashes_list:
                username = hash_line.split(":")[0]
                userhash = hash_line.split(":")[1]
                PASSWORD_GUESS_QUEUE.put((username,userhash))
            PASSWORD_GUESS_QUEUE.join()

        # Either has File
        elif args.passlist or args.hashlist:
            PASSWORD_GUESS_QUEUE = Queue()
            if args.passlist is not None:
                passwd_list = open_file(args.passlist)
                start_threads(passwd_list)
                PASSWORD_GUESS_QUEUE.put(("Username_Not_Provided",args.password_hash))

            elif args.hashlist is not None:
                hashes_list = open_file(args.hashlist)
                passwd_list = [args.password]
                start_threads(passwd_list)
                for hash_line in hashes_list:
                    username = hash_line.split(":")[0]
                    userhash = hash_line.split(":")[1]
                    PASSWORD_GUESS_QUEUE.put((username,userhash))
            PASSWORD_GUESS_QUEUE.join()
    except KeyboardInterrupt:
        keyboard_interrupt = "[!] Program Interrupted: CTRL+C detected. Exiting program now."
        print(keyboard_interrupt)
        sys.exit(130)
    except:
        undetermined_error = "[!] Undetermined Error Occured: Exiting program now"
        print(undetermined_error)
        sys.exit(1)

# Main Code
if __name__ == "__main__":
    try:
        start_time = time.time()
        main()
        print(f"Elapsed time: {time.time() - start_time} seconds")
        sys.exit(0)
    except KeyboardInterrupt:
        keyboard_interrupt = "[!] Program Interrupted: CTRL+C detected. Exiting program now."
        print(keyboard_interrupt)
        sys.exit(130)
    except:
        undetermined_error = "[!] Undetermined Error Occured: Exiting program now"
        print(undetermined_error)
        sys.exit(1)
