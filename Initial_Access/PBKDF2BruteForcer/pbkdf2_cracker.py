#!/usr/bin/env python3 -tt
#-*- coding: UTF-8 -*-

"""
NAME: pbkdf2_cracker.py
VERSION: 0.1.0
AUTHOR: Jesse Leverett (CyberThulhu)
STATUS: Building Initial code framework
DESCRIPTION: Brute Force and/or Check passwords against Redhat's 389-ds PBDKD2_SHA256 hashes
TO-DO: Implement Threading/Subprocessing; Clean Code; 
COPYRIGHT Â© 2022 Jesse Leverett
"""
# Using Rules for Password List: hashcat --force list.txt -r /usr/share/hashcat/rules/best64.rule --stdout > new_password.lst
# Getting LDAP Dump: ldapsearch -D "cn=Directory Manager" -x -W -b 'cn=users,cn=accounts,dc=ntdomain,dc=local' uid userpassword krbprincipalkey sambalmpassword sambantpassword

# Imports
from __future__ import absolute_import
from __future__ import print_function
import os
import sys
import time
import shlex
import base64
import socket
import struct
import hashlib
import argparse
import traceback
import subprocess
from queue import Queue
from threading import Thread, Lock

# Added Variables
__author__ = "Jesse Leverett"
__copyright__ = "Copyright (C) 2022 Jesse Leverett"
__license__ = "MIT License"
__version__ = "0.1"

# Argparser
PROG_DESCRIPTION = "Brute Force and/or Check passwords against Redhat's 389-ds PBDKD2_SHA256 hashes"
PROG_EPILOG = " Copyright (C) 2022 || Credit to 'thesubtlety' "
OUTPUTF_HELP_TEXT = "Path to Output File"
VERBOSE_HELP_TEXT = "Switch to Enable Verbosity"
VERSION_HELP_TEXT = "Print Version Information"
PWDHASH_HELP_TEXT = "Password Hash (\{PBKDF2_SHA256\}AAnE...)"
PASSWRD_HELP_TEXT = "Clear Text Password"
GENHASH_HELP_TEXT = "Generates a Hash using Supplied Password"
PASSLST_HELP_TEXT = "Path to List of Passwords (rockyou.txt)"
HASHLST_HELP_TEXT = "Path to List of PBKDF2 Hashes (Format Each on a New Line with username:hash)"
THREADN_HELP_TEXT = "Provide number of Threads (Default: 1)"

# Instantiate Argparser
parser = argparse.ArgumentParser( prog="pbkdf2_cracker", description=PROG_DESCRIPTION, epilog=PROG_EPILOG, formatter_class= argparse.RawDescriptionHelpFormatter)
password_parser = parser.add_mutually_exclusive_group(required=True)
hashword_parser = parser.add_mutually_exclusive_group(required=True)
# Standard Parsed Arguments
parser.add_argument('-o', '--output', metavar=r'./pbkdf2_cracker_output.txt', type=str, required=False, help=OUTPUTF_HELP_TEXT)
parser.add_argument('-v', '--verbose', required=False, action='store_true', help=VERBOSE_HELP_TEXT)
parser.add_argument('-t', '--threads', metavar="1", default=1, type=int, required=False, help=THREADN_HELP_TEXT)
parser.add_argument('--version', action="version", version=f" %(prog)s {__version__}", help=VERSION_HELP_TEXT)
# Password Arguments
password_parser.add_argument_group("Password Argument or List")
password_parser.add_argument('-p', '--password', type=str, metavar='password', required=False, help=PASSWRD_HELP_TEXT)
password_parser.add_argument('-pl', '--passlist', metavar='passwords.lst', required=False, help=PASSLST_HELP_TEXT)
# Hash Arguments
hashword_parser.add_argument_group("Hash Argument or List / Generate a Hash")
hashword_parser.add_argument('--hash', dest='password_hash', type=str, metavar='{PBKDF2_SHA256}AAnE...', required=False, help=PWDHASH_HELP_TEXT)
hashword_parser.add_argument('-hl', '--hashlist', metavar='hashes.lst', required=False, help=HASHLST_HELP_TEXT)
hashword_parser.add_argument('-g', '--generate', required=False, action='store_true', help=GENHASH_HELP_TEXT)

# Parse Arguments
args = parser.parse_args()

# Check if required arguments exist
if len(sys.argv[1:]) < 4:
    print(parser.print_help())
    exit(1)

# Defined Functions
def open_file(filename:None) -> list:
    """ Opens a Password List/Hashlist File if Provided """
    file_encoding, response = "UTF-8", "hashes"
    if args.passlist is filename:
        file_encoding, response = "ISO-8859-1", "passwords"
    with open(filename, encoding=file_encoding) as f:
        file_lines = [e.strip() for e in f.readlines() if e.strip()]
    print(f"Loaded {len(file_lines)} {response}...")
    return file_lines

def check_password_hash(username:str, userhash:str, passlist:list):
    """ Function """
    for ct_password in passlist:
        command = f"python3 {sys.argv[0]} -p {shlex.quote(ct_password)} --hash {shlex.quote(userhash)}"
        arguments = shlex.split(command)
        sub_process = subprocess.Popen(arguments, stdout=subprocess.PIPE)
        passlist, errs = sub_process.communicate()
        if b"Correct password" in passlist:
            print(f"{username}:{ct_password}")
            return

def ct_password_worker(passlist:list) -> None:
    """ Function """
    while True:
        username, userhash = password_guess_queue.get()
        try:
            check_password_hash(username, userhash, passlist)
        except Exception as e:
            traceback.print_exc(file=sys.stdout)
        password_guess_queue.task_done()

def base64_hash_from_data(tmp_key, salt, iterations):
    """ Base64 Hash from provided Data """
    iteration = int(iterations)
    iteration_bytes = struct.pack("I", socket.htonl(iteration))
    raw = iteration_bytes + salt + tmp_key
    buffer = "{PBKDF2_SHA256}" + str(base64.b64encode(raw))

    if args.verbose:
        print("Iterations:\n\\x" + "\\x".join(hex(c)[2:] for c in bytearray(iteration_bytes)) + " (%s)" % iterations)
        print("\nSalt:\n\\x" + "\\x".join(hex(c)[2:] for c in bytearray(salt)))
        print("\nKey:\n\\x" + "\\x".join(hex(c)[2:] for c in bytearray(tmp_key)))
        print()
    
    return buffer

def extract_hash_info(password_hash_389):
    """ Extracts 389-ds Hash Information """
    if password_hash_389[0] == "{":
        password_hash_389 = password_hash_389[15:]

    hash_bytes = base64.b64decode(password_hash_389)

    iteration_bytes = hash_bytes[0:4]
    iterations = int(socket.htonl(struct.unpack("I",iteration_bytes)[0]))
    assert(iterations < 1000000)
    
    salt = hash_bytes[4:68]
    target_key = hash_bytes[68:]
    
    return iterations, salt, target_key

def generate_pbkdf2_hash(ct_password:str=args.password):
    """ Generate PBKDF2 Hash with a Provided Plaintext Password """
    password = bytes(str(ct_password).encode('UTF-8'))
    salt = bytes(os.urandom(64))
    iterations = 10000
    temporary_key = hashlib.pbkdf2_hmac('sha256', password, salt, iterations, 256)
    return base64_hash_from_data(temporary_key, salt, iterations)

def start_threads(password_list:list, threads:int=args.threads) -> None:
    """ Function """
    for _ in range(0,threads):
        t = Thread(target=ct_password_worker,args=(password_list) ,daemon=True)
        t.start()

def run_compare(ct_password:str=args.password, hash_password:str=args.password_hash) -> str:
    """ Function Description """
    password = bytes(str(ct_password).encode('UTF-8'))
    iterations, salt, target_key = extract_hash_info(hash_password)
    temporary_key = hashlib.pbkdf2_hmac('sha256', password, bytes(salt), iterations, 256)

    if args.verbose:
        print(base64_hash_from_data(temporary_key, salt, iterations))

    if target_key == temporary_key:
        print("Success!:")
        print(f"{hash_password} : {ct_password}")
    else:
        print("\nIncorrect Password\n")

def main():
    """Main Code"""    
    # Generate a PBKDF2 Key
    if args.generate:
        print(generate_pbkdf2_hash())

    # One Password & One Hash
    if args.password and args.password_hash:
        run_compare()
    
    # Both has Files
    if args.passlist and args.hashlist:
        password_guess_queue = Queue()
        hashes_list = open_file(args.hashlist)
        passwd_list = open_file(args.passlist)
        start_threads(passwd_list)
        for hash_line in hashes_list:
            username = hash_line.split(":")[0]
            userhash = hash_line.split(":")[1]
            password_guess_queue.put((username,userhash))
        password_guess_queue.join()

    # Either has File
    if args.passlist or args.hashlist:
        password_guess_queue = Queue()
        if args.passlist is not None:
            passwd_list = open_file(args.passlist)
            start_threads(passwd_list)
            password_guess_queue.put(("NullUser",args.password_hash))
        
        if args.hashlist is not None:
            hashes_list = open_file(args.hashlist)
            passwd_list = list(args.password)
            start_threads(passwd_list)
            for hash_line in hashes_list:
                username = hash_line.split(":")[0]
                userhash = hash_line.split(":")[1]
                password_guess_queue.put((username,userhash))
        password_guess_queue.join()

# Main Code
if __name__ == "__main__":
    try:
        start_time = time.time()
        main()
        print(f"Elapsed time: {time.time() - start_time} seconds")
        sys.exit(0)
    except KeyboardInterrupt:
        sys.exit(1)
