#!/usr/bin/env python3 -tt
#-*- coding: UTF-8 -*-

import sys
import glob
import time
import pefile
import ctypes
import argparse
import itertools

'''
<Description>

        NAME:
                pe_scanner.py
        VERSION:
                0.0.1
        AUTHOR:
                Jesse Leverett (CyberThulhu)
        STATUS:
                <Status>: <Description>
        TO-DO:
                <To-Do>: <Description>

COPYRIGHT Â© 2023 Jesse Leverett
'''

# Added Variables
__author__ = "Jesse Leverett"
__copyright__ = "Modified: 2023 Author: Jesse Leverett"
__license__ = "MIT License"
__version__ = "0.1"

DLL_CHARS = [
	'reserved0',
	'reserved1',
	'reserved2',
	'reserved3',
	'undefined1',
	'High_Entropy_VA',
	'Dynamic_Base',
	'Force_Integrity',
	'NX_Compat',
	'No_isolation',
	'No_SEH',
	'No_bind',
	'App_Container',
	'WDM_Driver',
	'Guard_CF',
	'Terminal_Server_Aware'
]

# Instantiate Argparser
PROG_DESCRIPTION = "Scans a PE and Outputs Information about supplied PE."
PROG_EPILOG = __copyright__
parser = argparse.ArgumentParser( prog="pe_scanner", description=PROG_DESCRIPTION, epilog=PROG_EPILOG, formatter_class= argparse.RawDescriptionHelpFormatter)

# Add Arguments
OUTPUT_HELP_TEXT  = "Output Results to File"
VERSION_HELP_TEXT = "Version Information"
DUMP_HELP_TEXT    = "Dump all PE information. No Filters"
ADD_HELP_TEXT     = "Search for Defaults and additional Functions. (Multiple Functions: Space delineated, Terminated with '--')"
ONLY_HELP_TEXT    = "Search for Only listed Functions. (Multiple Functions: Space delineated, Terminated with '--')"
CASE_HELP_TEXT    = "Ignore Case. Allows for substring match"
FLAGS_HELP_TEXT   = "Display DLL Characteristic flags."
VERBOSE_HELP_TEXT = "Invokes verbosity."
TOGGLE_HELP_TEXT  = "The name of a Single Header Characteristic bit to toggle."
PEFILE_HELP_TEXT  = "Required: The name of an EXE or DLL. (Wildcards are supported)."

parser.add_argument('-d', '--dump', default=None, action="store_true", help=DUMP_HELP_TEXT)
parser.add_argument('-a', '--add', default=None, nargs='*', help=ADD_HELP_TEXT)
parser.add_argument('-o', '--only', default=None, nargs='*', help=ONLY_HELP_TEXT)
parser.add_argument('-i', '--ignore_case', default=None, nargs='*', help=CASE_HELP_TEXT)
parser.add_argument('-f', '--flags', nargs='*', help=FLAGS_HELP_TEXT)
parser.add_argument('-v', '--verbose', default=None, action="store_true", help=VERBOSE_HELP_TEXT)
parser.add_argument('-t', '--toggle', default=None, nargs='*', choices = DLL_CHARS, help=TOGGLE_HELP_TEXT)
parser.add_argument('-p', '--pefiles', required=True, default=None, help=PEFILE_HELP_TEXT)
parser.add_argument('--version', action="version", version=f" %(prog)s {__version__}", help=VERSION_HELP_TEXT)
parser.add_argument('-w', '--output', default=None, type=argparse.FileType('w'), required=False, help=OUTPUT_HELP_TEXT, metavar=r"./output.txt", dest="output")

# Parse Arguments
args = parser.parse_args()

# Basic Checks

# Defined Functions
def search_tables(thefile, pename, search = []):
	'''
	Main Code

			Parameters:
			----------
					thefile
					pename
					search

			Returns:
			-------
					None
	'''

	if hasattr(thefile, "DIRECTORY_ENTRY_IMPORT"):
		if args.verbose or args.dump:
			print("[+] Processing Import Table...")

		for dllimport in thefile.DIRECTORY_ENTRY_IMPORT:
			fname = dllimport.dll.decode()
			for eachfunc in dllimport.imports:
				if args.dump:
					name = eachfunc.name if eachfunc.name else b"BLANK"
					print("\t[i] {0: >} in {1} at offset 0x{2:0>16X}".format(name.decode(),fname,eachfunc.address ))
					continue
				for eachterm in search:                   
					if args.ignore_case:
						if eachfunc.name and (eachterm in eachfunc.name.decode().lower()) or not search:
							print("\t[i] {} uses {} in dll {}".format(pename, eachfunc.name, fname))
					else:
						if eachfunc.name and eachterm == eachfunc.name.decode():
							print("\t[i] {} uses {} in dll {}".format(pename, eachfunc.name, fname))
	if hasattr(thefile, "DIRECTORY_ENTRY_EXPORT"):
		if args.verbose or args.dump:
			print("[+] Processing the Export Table...")
		for symbol in thefile.DIRECTORY_ENTRY_EXPORT.symbols:
			fname = thefile.DIRECTORY_ENTRY_EXPORT.name.decode()
			if args.dump:
				name = symbol.name if symbol.name else b"BLANK"
				print("\t[i] {0} in {1} at offset 0x{2:0>16X} in {}".format(name.decode(), fname, symbol.address_offset))
				continue
			for eachterm in search:
				if symbol.name:
					if args.ignore_case:
						if symbol.name and (eachterm in symbol.name.decode().lower()) or not search:
							print("\t[i] {0} exports {1} at 0x{2:0>16X} ".format(pename, symbol.name, symbol.address_offset))
					else:
						if symbol.name and eachterm == symbol.name.decode():
							print("\t[i] {0} exports {1} at 0x{2:0>16X}".format(pename, symbol.name, symbol.address_offset))

def bits2flag(flags,byte_value):
    '''
    Main Code

            Parameters:
            ----------
                    flags
					byte_value

            Returns:
            -------
                    None
    '''
    bits_array = map(int, format(byte_value,"016b"))
    return "|".join(itertools.compress(flags[::-1],bits_array))

def togglebit(flags, toggle_flag, byte_value):
	'''
	Main Code

			Parameters:
			----------
					flags
					toggle_flag
					byte_value

			Returns:
			-------
					None
	'''
	bits_mask = 2**flags.index(toggle_flag)
	return byte_value ^ bits_mask    
							
def main() -> None:
	'''
	Main Code

			Parameters:
			----------
					None

			Returns:
			-------
					None
	'''
	try:
		main_start = "[!] Starting program"
		print(main_start)
		
		search = ["printf","gets","lstrcpyW"]
		
		pefiles = glob.glob(args.pefiles)

		if len(pefiles) == 0:
			print("No files found.")
			sys.exit(1)

		if args.add:
			search.extend(args.add)

		if args.only:
			search = args.only

		for pe in pefiles:
			try:
				thefile = pefile.PE(pe)
			except Exception as e:
				print(f"[!] Unable to open file: {e}")
				continue

			if args.dump or args.flags:
				file_options = thefile.OPTIONAL_HEADER.DllCharacteristics
				print("\t[i] {} flags : {}".format(pe, bits2flag(DLL_CHARS, file_options)))

			if args.toggle:
				current_flags = thefile.OPTIONAL_HEADER.DllCharacteristics
				bitmask = 0
				for eachflag in args.toggle:
					bitmask = bitmask ^ (2**DLL_CHARS.index(eachflag))
				thefile.OPTIONAL_HEADER.DllCharacteristics = current_flags ^ bitmask
				thefile.write(filename = f"{pe}.new")
				print(f"[+] New File created: {pe}.new")

			if args.verbose:
				print(f"\t[i] Searching EXE {pe} for vulnerable functions:")
				for funct in search:
					print(f"\t\t[-] {funct}")

			search_tables(thefile, pe, search)

	except KeyboardInterrupt:
		keyboard_interrupt = "[!] Program Interrupted: CTRL+C detected. Exiting program now."
		print(keyboard_interrupt)
		sys.exit(130)
	except Exception as e:
		undetermined_error = "[!] Undetermined Error Occurred: Exiting program now"
		print(undetermined_error)
		print(e)
		sys.exit(1)

# Main Code
if __name__ == "__main__":
	try:
		if args.verbose:
			start_time = time.time()
		main()
		if args.verbose:
			print(f"[i] Elapsed time: {time.time() - start_time} seconds")
		sys.exit(0)
	except KeyboardInterrupt:
		keyboard_interrupt = "[!] Program Interrupted: CTRL+C detected. Exiting program now."
		print(keyboard_interrupt)
		sys.exit(130)
	except Exception as e:
		undetermined_error = "[!] Undetermined Error Occurred: Exiting program now"
		print(undetermined_error)
		print(e)
		sys.exit(1)