#!/usr/bin/env python3
#-*- coding: UTF-8 -*-

'''
Takes IPv4/6 Addresse(s) and Verifies if they are in Single/Multiple of Offlimits Networks

        NAME:
                offlimits_verifier.py
        VERSION:
                1.1.0
        AUTHOR:
                Jesse Leverett (CyberThulhu)
        STATUS:
                Completed: Code has been tested and works.
        TO-DO:
                Output Functionality:       Need to add functionality to send to an output file.
                Verbosity Functionality:    Add verbose information for specific information
                Conform to Standards:       Run code through pylint to follow python PEP standards.

COPYRIGHT Â© 2022 Jesse Leverett
'''

# Imports
import sys
import time
import argparse
import ipaddress
from io import TextIOWrapper

# Added Variables
__author__ = "Jesse Leverett"
__copyright__ = "Copyright (C) 2021 Jesse Leverett"
__license__ = "MIT License"
__version__ = "0.1"

# Instantiate Argparser
PROG_DESCRIPTION = "Takes IPv4/6 Addresse(s) and Verifies if they are in Offlimit(s) IPs/Networks"
PROG_EPILOG = __copyright__

parser = argparse.ArgumentParser( prog="offlimits_verifier",
                                description=PROG_DESCRIPTION, epilog=PROG_EPILOG,
                                formatter_class= argparse.RawDescriptionHelpFormatter)

# Add Arguments
OUTPUT_HELP_TEXT = "File to send output to"
VERSION_HELP_TEXT = "Prints verision information"
SINGLE_HELP_TEXT = "Testcase IPv4/IPv6"
IPLIST_HELP_TEXT = "Testcase IPv4/IPv6 List"
OFFLIP_HELP_TEXT = "Offlimit IPv4/IPv6"
OFFIPL_HELP_TEXT = "Offlimits IPv4/IPv6 List (Format: <ip_net>[/<cidr>])"

#parser.add_argument('-o', '--output', default=None, type=str, required=False,
#                   help=OUTPUT_HELP_TEXT, metavar=r'C:\IP-List.txt', dest="output")
parser.add_argument('--version', action="version", version=f" %(prog)s {__version__}",
                    help=VERSION_HELP_TEXT)
provip = parser.add_mutually_exclusive_group(required=False)
offlip = parser.add_mutually_exclusive_group(required=False)
provip.add_argument('-ip', '--ipaddr', nargs=1, default=None, type=str, required=False,
                    help=SINGLE_HELP_TEXT, metavar="127.0.0.1", dest="ip_address")
provip.add_argument('-iL', '--iplist', default=None,
                    type=argparse.FileType(mode='r', encoding="UTF-8"), required=False,
                    help=IPLIST_HELP_TEXT, metavar=r"./IPAddress.txt",
                    dest="ip_address_list")
offlip.add_argument('-op', '--offlip', nargs=1, default=None, type=str, required=False,
                    help=OFFLIP_HELP_TEXT, metavar="127.0.0.1", dest="offlimits_ip_address")
offlip.add_argument('-oL', '--offipl', default=None,
                    type=argparse.FileType(mode='r', encoding="UTF-8"), required=False,
                    help=OFFIPL_HELP_TEXT, metavar=r"./Offlimits.txt",
                    dest="offlimits_ip_address_list")

# Parse Arguments
args = parser.parse_args()

# Defined Functions
def check_for_cidr(ip_address:str) -> bool:
    '''
    Checks a IP Address string for a CIDR notation and returns True or False

            Parameters:
            ----------
                    ip_address (str): String of IP Address

            Returns:
            -------
                    cidr_verification (bool): True or False
    '''
    field_separator = "/"
    cidr_verification = bool(field_separator in ip_address[-3:])
    return cidr_verification

def get_unique_list_values(provided_list:list) -> list:
    '''
    Gets unique values within a provided list

            Parameters:
            ----------
                    provided_list (list):

            Returns:
            -------
                    unique_list (list):
    '''
    unique_list = list(set(provided_list))
    return unique_list

def ipaddr_hosts_list(opened_ipaddr_list:TextIOWrapper) -> list:
    '''
    Returns a complete list of testcase IPv4/IPv6 addresses.

            Parameters:
            ----------
                    opened_testcases_list (TextIOWrapper): Opened file with a list of Testcase IPs.

            Returns:
            -------
                    unique_ipaddr_list (list): Unique and Sorted List of IPv4/IPv6 Addresses
    '''
    ipaddr_list = []
    for ip_address in opened_ipaddr_list.readlines():
        if check_for_cidr(ip_address.strip()):
            try:
                network_address = ipaddress.ip_network(ip_address.strip(),False)
                network_list = list(network_address)
                ipaddr_list += [str(ipaddress.ip_address(ip_addr)) for ip_addr in network_list]
            except ValueError:
                pass
        else:
            ipaddr_list.append(ip_address.strip())
    unique_ipaddr_list = get_unique_list_values(ipaddr_list)
    return sorted(unique_ipaddr_list)

def ipaddr_host(single_provided:list) -> list:
    '''
    Creates a List for a Single/CIDR IP address provided

            Parameters:
            ----------
                    single_provided (list): Single IPv4/IPv6 Address and/or CIDR

            Returns:
            -------
                    ipaddr_list (list): Expanded List of IPv4/IPv6 Address
    '''
    if check_for_cidr(single_provided[0]):
        ipaddr_list = [str(ipaddress.ip_address(ip_addr)) for ip_addr in ipaddress.ip_network(single_provided[0],False)]
    else:
        ipaddr_list = single_provided
    return ipaddr_list

def check_if_offlimits(ipaddr:str, offlimit_list:list) -> bool:
    '''
    Check if the IP Address is in the Offlimits List and returns True/False

            Parameters:
            ----------
                    ipaddr (str):
                    offlimit_list (list, TextIOWrapper):

            Returns:
            -------
                    offlimit_ipaddr (bool): Returns True/False if IP Address is Offlimits
    '''
    offlimit_ipaddr = False
    binrep_ipaddr = int(ipaddress.ip_address(ipaddr))
    while offlimit_ipaddr is False:
        for ipnetw in offlimit_list:
            netaddr = ipaddress.ip_network(ipnetw.strip(), False)
            netw = int(netaddr.network_address)
            mask = int(netaddr.netmask)
            offlimit_ipaddr = (binrep_ipaddr & mask) == netw
            if offlimit_ipaddr:
                break
        break
    return offlimit_ipaddr

def main():
    '''
    Main Method

            Parameters:
            ----------
                    None

            Returns:
            -------
                    None
    '''
    try:
        if args.ip_address is not None:
            testcases_list = ipaddr_host(args.ip_address)
        else:
            testcases_list = ipaddr_hosts_list(args.ip_address_list)
        if args.offlimits_ip_address_list is not None:
            opened_file = args.offlimits_ip_address_list.readlines()
            for ip_address in testcases_list:
                in_network = check_if_offlimits(ip_address, opened_file)
                if in_network:
                    print(f"[-] {ip_address}: OFFLIMITS")
                else:
                    print(f"[+] {ip_address}: VIABLE ADDRESS")
        else:
            for ip_address in testcases_list:
                in_network = check_if_offlimits(ip_address, args.offlimits_ip_address)
                if in_network:
                    print(f"[-] {ip_address}: OFFLIMITS")
                else:
                    print(f"[+] {ip_address}: VIABLE")
    except KeyboardInterrupt:
        kb_interrupt = "[!] Program Interrupted: CTRL+C detected.\n[i] Exiting program now."
        print(kb_interrupt)
        sys.exit(130)
    except ValueError as valerr:
        print(f"[!] Value Error Occured: {valerr}.\n[i] Exiting program now.")
        sys.exit(31)
    except (Exception,):
        undetermined_error = "[!] Undetermined Error Occured.\n[i] Exiting program now."
        print(undetermined_error)
        sys.exit(1)

# Main Code
if __name__ == "__main__":
    try:
        start_time = time.time()
        main()
        print(f"Elapsed time: {time.time() - start_time} seconds")
        sys.exit(0)
    except KeyboardInterrupt:
        KB_INTERRUPT = "[!] Program Interrupted: CTRL+C detected.\n[i] Exiting program now."
        print(KB_INTERRUPT)
        sys.exit(130)
    except (Exception,):
        UNDETERMINED_ERR = "[!] Undetermined Error Occured:\n[i] Exiting program now."
        print(UNDETERMINED_ERR)
        sys.exit(1)
