#!/usr/bin/env python3
#-*- coding: UTF-8 -*-

"""
NAME: offlimits_verifier.py
VERSION: 0.1
AUTHOR: Jesse Leverett (CyberThulhu)
STATUS: Building Initial code framework
DESCRIPTION: Takes Single/Multiple IPv4/6 Addresses and Verifies if they are in Single/Multiple of Offlimits Networks
TO-DO:
    Build Initial Code Framework
    Clean Code
    Conform to Pylint Standards
COPYRIGHT Â© 2021 Jesse Leverett
"""

# Imports

import sys
import time
import argparse
import ipaddress
from io import TextIOWrapper


# Added Variables
__author__ = "Jesse Leverett"
__copyright__ = "Copyright (C) 2021 Jesse Leverett"
__license__ = "MIT License"
__version__ = "0.1"

# Instantiate Argparser
PROG_DESCRIPTION = "Takes Single/Multiple IPv4/6 Addresses and Verifies if they are in Single/Multiple of Offlimits Networks"
PROG_EPILOG = __copyright__

parser = argparse.ArgumentParser( prog="offlimits_verifier", description=PROG_DESCRIPTION, epilog=PROG_EPILOG, formatter_class= argparse.RawDescriptionHelpFormatter)

# Add Arguments
OUTPUT_HELP_TEXT = ""
VERSION_HELP_TEXT = ""
SINGLE_HELP_TEXT = ""
IPLIST_HELP_TEXT = ""
OFFLIP_HELP_TEXT = "Offlimit IP"
OFFIPL_HELP_TEXT = "Offlimits IP List (Format: <ip_net>[/<cidr>])"

parser.add_argument('-o', '--output', default=None, type=str, required=False, help=OUTPUT_HELP_TEXT, metavar=r'C:\IP-List.txt', dest="output")
parser.add_argument('--version', action="version", version=f" %(prog)s {__version__}", help=VERSION_HELP_TEXT)

provip = parser.add_mutually_exclusive_group(required=True)
offlip = parser.add_mutually_exclusive_group(required=True)

provip.add_argument('-ip', '--ipaddr', nargs=1, default='127.0.0.1', type=str, required=False, help=SINGLE_HELP_TEXT, metavar="127.0.0.1", dest="ip_address")
provip.add_argument('-iL', '--iplist', default=None, type=argparse.FileType(mode='r', encoding="UTF-8"), required=False, help=IPLIST_HELP_TEXT, metavar=r"./IP-List.txt", dest="ip_address_list")

offlip.add_argument('-op', '--offlip', nargs=1, default='127.0.0.1', type=str, required=False, help=OFFLIP_HELP_TEXT, metavar="127.0.0.1", dest="offlimits_ip_address")
offlip.add_argument('-oL', '--offipl', default=None, type=argparse.FileType(mode='r', encoding="UTF-8"), required=False, help=OFFIPL_HELP_TEXT, metavar=r"./Offlimits-List.txt", dest="offlimits_ip_address_list")

# Parse Arguments
args = parser.parse_args()

# Defined Functions
def check_for_cidr(ip_address:str) -> bool:
    '''
    Checks a IP Address string for a CIDR notation and returns True or False

            Parameters:
            ----------
                    ip_address (str): String of IP Address

            Returns:
            -------
                    cidr_verification (bool): True or False
    '''
    field_separator = "/"
    if field_separator in ip_address[-3:]:
        cidr_verification = True
    else:
        cidr_verification = False
    return cidr_verification

def offlimits_hosts_list(opened_offlimits_list:TextIOWrapper=args.offlimits_ip_address_list) -> list:
    '''
    Returns a complete list offlimits IPv4/IPv6 addresses.

            Parameters:
            ----------
                    opened_offlimits_list (TextIOWrapper) -> args.offlimits_ip_address_list: A opened file with a list of Offlimits IPs.

            Returns:
            -------
                    python_offlimits_list (list): List of expanded offlimits IPs.
    '''
    python_offlimits_list = []
    for ip_network in opened_offlimits_list.readlines():
        if check_for_cidr(ip_network.strip()):
            # Going to need a try statement for in case cidr input is greater than 32 or negative number
            network_list = list(ipaddress.ip_network(ip_network.strip(), False))
            python_offlimits_list += [ str(ipaddress.ip_address(ip_addr)) for ip_addr in network_list ]
        else:
            python_offlimits_list.append(ip_network.strip())
    return python_offlimits_list

def testcases_hosts_list(opened_testcases_list:TextIOWrapper=args.ip_address_list) -> list:
    '''
    Returns a complete list of testcase IPv4/IPv6 addresses.

            Parameters:
            ----------
                    opened_testcases_list (TextIOWrapper) -> args.ip_address_list: A opened file with a list of Testcase IPs.

            Returns:
            -------
                    python_testcases_list (list):
    '''
    python_testcases_list = []
    for ip_address in opened_testcases_list.readlines():
        if check_for_cidr(ip_address.strip()):
            # Going to need a try statement for in case cidr input is greater than 32 or negative number
            network_list = list(ipaddress.ip_network(ip_address.strip(), False))
            python_testcases_list += [ str(ipaddress.ip_address(ip_addr)) for ip_addr in network_list ]
        else:
            python_testcases_list.append(ip_address.strip())
    return python_testcases_list

def main():
    '''
    Main Method

            Parameters:
            ----------
                    None

            Returns:
            -------
                    None
    '''
    try:
        offlimits_list = offlimits_hosts_list()
        testcases_list = testcases_hosts_list()
        for ip_address in testcases_list:
            if ip_address in offlimits_list:
                print(f"[-] {ip_address}: OFFLIMITS")
            else:
                print(f"[+] {ip_address}: Viable Target")
    except KeyboardInterrupt:
        keyboard_interrupt = "[!] Program Interrupted: CTRL+C detected. Exiting program now."
        print(keyboard_interrupt)
        sys.exit(130)
    except:
        undetermined_error = "[!] Undetermined Error Occured: Exiting program now"
        print(undetermined_error)
        sys.exit(1)

# Main Code
if __name__ == "__main__":
    try:
        start_time = time.time()
        main()
        print(f"Elapsed time: {time.time() - start_time} seconds")
        sys.exit(0)
    except KeyboardInterrupt:
        keyboard_interrupt = "[!] Program Interrupted: CTRL+C detected. Exiting program now."
        print(keyboard_interrupt)
        sys.exit(130)
    except:
        undetermined_error = "[!] Undetermined Error Occured: Exiting program now"
        print(undetermined_error)
        sys.exit(1)
