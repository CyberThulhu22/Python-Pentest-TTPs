#!/usr/bin/env python3
"""
NAME: header_inspector.py
VERSION: 0.0.2
AUTHOR: Jesse Leverett (CyberThulhu)
STATUS: Building Initial code framework
DESCRIPTION:
TO-DO:
    - Add help/description texts
    - Finish writing other functions
    - Build Main function and Order of Operations
COPYRIGHT Â© 2021 Jesse Leverett
"""

# Imports
import re
import sys
import ssl
import argparse
from socket import gethostbyname
from urllib import request, error
from datetime import datetime

# Added Variables
__author__ = "Jesse Leverett"
__copyright__ = "Copyright (C) 2021 Jesse Leverett"
__license__ = "MIT License"
__version__ = "1.0"

# Instantiate Argparser
PROG_DESCRIPTION = ""
PROG_EPILOG = ""
parser = argparse.ArgumentParser(description = PROG_DESCRIPTION, epilog = PROG_EPILOG,
                                formatter_class= argparse.RawDescriptionHelpFormatter)
parser_url = parser.add_mutually_exclusive_group(required=True)

# Add Arguments
OUTPUT_HELP_TEXT = ""
URL_HELP_TEXT = ""
URL_LIST_HELP_TEXT = ""
VERBOSE_HELP_TEXT = ""

parser_url.add_argument('-u', '--url', metavar=r'http://url.com/', type=str,
                    help=URL_HELP_TEXT)
parser_url.add_argument('-l', '--urllist', metavar=r'C:\IP-List.txt', type=str,
                    help=URL_LIST_HELP_TEXT)
parser.add_argument('-o', '--output', metavar=r'C:\IP-List.txt', type=str,
                    required=False, help=OUTPUT_HELP_TEXT)
parser.add_argument('-v', '--verbose', default=False, required=False,
                    action="store_true", help=VERBOSE_HELP_TEXT)

# Parse Arguments
args = parser.parse_args()

# Created Class
class URLObject:
    """ URL Object Class """
    def __init__(self, website_url):
        """ Initialization of URL Object Class """
        self.website_url = website_url
        self.cert_context = ssl.create_default_context()
        self.cert_context.check_hostname = False
        self.cert_context.verify_mode = ssl.CERT_NONE
        self.shorter_url = (self.website_url).split("/")[2]

    def url_ipaddr(self):
        """ Get URL's IP Address """
        if args.verbose is True:
            print(f"[!] INFO: Getting IP Address for URL: {self.website_url}")
        found_url_ipaddr = gethostbyname(self.shorter_url)
        return f"URL: {self.shorter_url:<25} IP: {found_url_ipaddr:15}\n"

    def url_protocol(self):
        """ Verify if HTTP or HTTPS """
        if args.verbose is True:
            print("[!] INFO: Checking Protocol for URL")
        var_url_protocol = self.website_url.split(":")[0]
        return var_url_protocol.upper()

    def url_status_code(self):
        """ Verify 200 Connectivity """
        if args.verbose is True:
            print("[!] INFO: Testing connectivity to URL.")
        try:
            with request.urlopen(self.website_url, context = self.cert_context, timeout=10) as req:
                successful_connect = req.status == 200
                if successful_connect is True:
                    if args.verbose is True:
                        print("[+] SUCCESS: Website is Online")
                    return True
                print("[-] ERROR: Website is Offline")
                sys.exit(1)
        except error.HTTPError as httperr:
            response_data = httperr.read().decode("utf-8", "ignore")
            print(f"[-] ERROR: (HTTP ERR): {response_data}")
            sys.exit(1)
        except error.URLError:
            print("[-] ERROR: (URL ERR): Target actively refused connection.")
            sys.exit(1)

    def url_response_headers(self):
        """ Get URL's Response Headers """
        if args.verbose is True:
            print(f"[!] INFO: Making request to {self.website_url}.")
        try:
            with request.urlopen(self.website_url, context = self.cert_context, timeout=10) as req:
                if args.verbose is True:
                    print(f"[+] SUCCESS: Completed Request to {self.website_url}.")
                return str(req.info())
        except error.HTTPError as httperr:
            response_data = httperr.read().decode("utf-8", "ignore")
            print(f"[-] ERROR: (HTTP ERR): {response_data}")
            sys.exit(1)
        except error.URLError:
            print("[-] ERROR: (URL ERR): Target actively refused connection.")
            sys.exit(1)

    def url_specific_headers(self, specific_header_list, input_response_headers):
        """ Look for Specific Headers within Response """
        if args.verbose is True:
            print(f"[!] INFO: Looking for Security Headers for {self.website_url}")
        verified_specific_headers = []
        for header in specific_header_list:
            if header.lower() in str(input_response_headers).lower():
                re_header = re.findall(f"{header}.*", str(input_response_headers), re.IGNORECASE)[0]
                verified_specific_headers.append(re_header)
            else:
                verified_specific_headers.append(f"{header}:")
        return verified_specific_headers

# Created Definitions
def open_file(unopened_file = args.urllist):
    """ Open a File """
    opened_file_data = []
    with open(fr"{unopened_file}", "r", encoding="utf-8") as opened_file:
        for line in opened_file.readlines():
            opened_file_data.append(line.rstrip())
    return opened_file_data

def create_output(verified_specific_headers_list):
    """ Design Output """
    if args.verbose is True:
        print("[!] INFO: Outputting Specific Header Information")
    return_output = ""
    for specific_header in verified_specific_headers_list:
        split_header = specific_header.split(":")
        if split_header[1] != "":
            return_output += f"{split_header[0]:<25} is declared     -> DATA:{split_header[1]:30}\n"
        else:
            return_output += f"{split_header[0]:<25} is NOT declared -> NO DATA\n"
    return return_output

def write_file(result_data, output_file = args.output):
    """ Write to a File """
    print(fr"[!] INFO: Writing output to {output_file}")
    if output_file is not None:
        with open(output_file, "a", encoding="utf-8") as opened_output_file:
            opened_output_file.write(result_data)
        return f"[!] INFO: Results written to {output_file}"
    return result_data

def main(url_var):
    """ Main Function """
    main_buffer = ""
    specific_headers = ["Strict-Transport-Security", "Content-Security-Policy", "X-Frame-Options"]
    url_object = URLObject(url_var)
    url_proto  = url_object.url_protocol()
    if url_proto == "HTTP":
        specific_headers.pop(0)
    if url_object.url_status_code() is True:
        main_buffer += url_object.url_ipaddr()
        url_response = url_object.url_response_headers()
        if args.verbose is True:
            main_buffer += url_response
        url_specific_headers_list = url_object.url_specific_headers(specific_headers, url_response)
        main_buffer += create_output(url_specific_headers_list)
    return main_buffer

if __name__ == "__main__":
    try:
        start_time = datetime.now()
        if args.url is not None:
            if args.output is not None:
                write_file(main(args.url))
            else:
                print(main(args.url))
        elif args.urllist is not None:
            if args.output is not None:
                for url_line in open_file(args.urllist):
                    write_file(main(url_line))
            else:
                for url_line in open_file(args.urllist):
                    print(main(url_line))
        end_time = datetime.now()
        exec_time = end_time - start_time
        if args.verbose is True:
            print(f"[!] INFO: Total execution time: {exec_time}")
        sys.exit(0)
    except KeyboardInterrupt:
        print("[-] KEY INTERRUPT: Program will now EXIT")
        sys.exit(1)
