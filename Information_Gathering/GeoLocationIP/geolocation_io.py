"""
NAME: GeoLocationIP.py
VERSION: 1.0.0
AUTHOR: Jesse Leverett (CyberThulhu)
STATUS: Complete; Pending Updates/Bug Reports
DESCRIPTION: Queries an Single/CIDR/List of IP Addresses for Info from API IPGeolocation IO
TO-DO: Update as Necessary
COPYRIGHT Â© 2021 Jesse Leverett
"""
import sys
import json
import argparse
import ipaddress
import getpass
from urllib import request, error
from datetime import datetime

# Instantiate Argument Parser
DESC_TEXT = "Queries an Single, CIDR, or List of IP Addresses for Info from API IPGeolocation IO"
EPILOG_TEXT = "*You will need an API Key from https://api.ipgeolocation.io to run this script\n"

argumnt = argparse.ArgumentParser(description= f"{DESC_TEXT}", epilog= f"{EPILOG_TEXT}",
                                formatter_class= argparse.RawDescriptionHelpFormatter)
ipgroup = argumnt.add_mutually_exclusive_group(required=True)
authkey = argumnt.add_mutually_exclusive_group(required=False)

# Create Arguments
OUTPUT_HELP_TEXT = "Enter Path to File that Results will be Recorded to"
IPADDR_HELP_TEXT = "Enter IP Address or IP with CIDR (Example: 8.8.8.8 or 8.8.8.0/24)"
IPLIST_HELP_TEXT = "Enter Path to File containing IP Addresses, each on a new line"
APIKEY_HELP_TEXT = "Enter API Key for Batch Mode ONLY (API Key should remain secured)"
EXAMPLE_FILE = r"C:\Example.txt"

argumnt.add_argument('-o', '--output', metavar=EXAMPLE_FILE,
                    type=str, required=False, help=OUTPUT_HELP_TEXT)
ipgroup.add_argument('-i', '--ipaddr', metavar='ipaddr',
                    type=str, help=IPADDR_HELP_TEXT)
ipgroup.add_argument('-iL','--iplist', metavar=EXAMPLE_FILE,
                    type=str, help=IPLIST_HELP_TEXT)
authkey.add_argument('-a', '--apikey', metavar='abc123', nargs="?",default=None,
                    type=str, help=APIKEY_HELP_TEXT)

# Parse Arguments
args = argumnt.parse_args()

# Defined Class
class IPGeoLocationIO:
    """IP Address Geolocation Class"""
    def __init__(self, ip_address=None, api_key=None):
        self.ipaddr = ip_address
        self.apikey = api_key
        self.url = "https://api.ipgeolocation.io"

    def check_valid_ip_struct(self):
        """Checks if string is an IP Address"""
        try:
            ipaddress.ip_address(self.ipaddr)
            print(f"[+] TASK: Gathering Information for Address/Netmask: {self.ipaddr}")
            return True
        except ValueError:
            print(f"[-] ERROR: Address/Netmask is invalid...Skipping: {self.ipaddr}")
            return False

    def test_connection(self):
        """Test Connection to Website before Querying"""
        # Test connection to provided URL/URI
        try:
            with request.urlopen(self.url) as status_code:
                successful_connect = status_code.getcode() == 200
                if successful_connect is True:
                    return "[+] TASK: Website is online! Proceeding..."
                print("[-] ERROR (HTML: 404): The website appears to not be up")
                sys.exit(1)
        except error.HTTPError as httperr:
            response_data = httperr.read().decode("utf-8", "ignore")
            print(f"[-] ERROR (HTTP Error): {response_data}")
            sys.exit(1)
        except error.URLError:
            print("[-] ERROR (WIN: 10061): Target actively refused connection.")
            sys.exit(1)

    def build_query(self):
        """Build Query to IPGeo Website"""
        building_url = f"{self.url}/ipgeo?apiKey={self.apikey}&ip={self.ipaddr}"
        return building_url

    def make_request(self, req_url):
        """Make Request to IPGeo Website"""
        print(f"[+] TASK: Making request to api.ipgeolocation.io: IP -- {self.ipaddr}")
        try:
            with request.urlopen(req_url) as req:
                return req.read().decode("utf-8")
        except error.HTTPError as httperr:
            response_data = httperr.read().decode("utf-8", "ignore")
            print(f"[-] ERROR (HTTP Error): {response_data}")
            sys.exit(1)


# Defined Functions
def get_apikey():
    """Get API Key from User Input if one not provided"""
    print("[+] TASK: Please Copy and Paste your API key! (Input will be Invisible)")
    return getpass.getpass("   [>] API_KEY: ")

def read_file(file=args.iplist):
    """Reads a File"""
    # Open and Read a File
    outfile = []
    with open(fr'{file}', 'r', encoding="utf-8") as infile:
        for line in infile:
            outfile.append(line.rstrip())
    return outfile

def output_results(result_to_outfile, outfile=args.output):
    """Outputs results to a file or to the screen"""
    if outfile is not None:
        with open(str(outfile), "a", encoding="utf-8") as output_file:
            output_file.write(result_to_outfile)
        return f"[!] INFO: Results written to {output_file}"
    return result_to_outfile

def json_print(result_data, result_ipaddr=args.ipaddr):
    """Prints output from JSON"""
    dash = "-" * 50
    header = "HEADER"
    data = "DATA"
    result_header = dash
    result_header += f"\nIP ADDRESS: {result_ipaddr}"
    result_header += f"\n{header:<25}{data:6}\n"
    result_header += dash + "\n"
    for key, value in result_data.items():
        if isinstance(value, dict):
            res_data = json.dumps(value)
            result_header += f"{key:<25}{res_data:6}\n"
        else:
            result_header += f"{key:<25}{value:6}\n"
    return result_header

def process_cidr(network = args.ipaddr):
    """Processes CIDR to a Correct String"""
    try:
        return ipaddress.ip_network(ipaddress.ip_interface(network).network).with_prefixlen
    except ValueError:
        print("[-] ERROR: Address Entered is not an IPv4/6 Interface")
        sys.exit(1)

def build_cidr_list(cidr_list=None):
    """Create List of IP Addresses Based on CIDR"""
    return [ str(ip) for ip in ipaddress.IPv4Network(cidr_list) ]

def main(ip_addr, key):
    """Main Functions"""
    listed_address = IPGeoLocationIO(ip_addr, key)
    if listed_address.check_valid_ip_struct() is True:
        built_url = listed_address.build_query()
        response_data = json.loads(listed_address.make_request(built_url))
        print(output_results(json_print(response_data, ip_addr)))

if __name__ == "__main__":

    try:
        start_time = datetime.now()
        IPGeoLocationIO().test_connection()
        if args.apikey is None:
            args.apikey = get_apikey()

        if args.ipaddr is not None:
            if "/" in args.ipaddr[-3::1]:
                get_cidr_list = process_cidr(args.ipaddr)
                ip_cidr_list = build_cidr_list(get_cidr_list)
                for ipaddr in ip_cidr_list:
                    main(ipaddr, args.apikey)
            else:
                main(args.ipaddr, args.apikey)

        elif args.iplist is not None:
            for ipaddr in read_file(args.iplist):
                main(ipaddr, args.apikey)

        end_time = datetime.now()
        exec_time = end_time - start_time
        print(f"[!] INFO: Total execution time for the function {exec_time}")
        sys.exit(0)

    except KeyboardInterrupt:
        print("[-] KEY INTERRUPT: Program will now EXIT!")
        sys.exit(0)
